#!/bin/sh
# ============================================================================
# srcmgr — gerenciador source-based minimalista (POSIX sh, LFS-friendly)
# ----------------------------------------------------------------------------
# Receitas: arquivos .rc com APENAS VARIÁVEIS (sem funções). Exemplo:
#   PKG="hello"
#   VER="2.12.1"
#   SRC="https://ftp.gnu.org/gnu/hello/hello-2.12.1.tar.gz"
#   SHA256="..."
#   DEPS="gettext"
#   PATCHES="
#     patches/fix-foo.patch
#   "
#   CONFIGURE="./configure --prefix=\${PREFIX}"
#   MAKE="make -j\${JOBS}"
#   MAKE_INSTALL="make DESTDIR=\${DESTDIR} install"
#   POST_INSTALL=""    # comandos para rodar no ROOT após instalar
#   REMOVE_CMDS=""     # comandos ao remover (ex.: systemd disable, userdel)
#   BUILD_DIR=""       # opcional: diretório de build/fonte
#
# Estrutura do repo esperada (ex. $REPO=/usr/local/srcmgr):
#   $REPO/
#     .git
#     repo/
#       base/
#         hello.rc
#         gcc.rc
#       extra/
#         firefox.rc
#
# Comandos:
#   srcmgr install  <nome|arquivo.rc> [--force]
#   srcmgr build    <nome|arquivo.rc>            (compila/empacota sem instalar)
#   srcmgr fetch    <nome|arquivo.rc>
#   srcmgr extract  <nome|arquivo.rc>
#   srcmgr patch    <nome|arquivo.rc>
#   srcmgr deps     <nome|arquivo.rc>            (instala deps recursivamente)
#   srcmgr remove   <nome[-ver]>
#   srcmgr list
#   srcmgr info     <nome[-ver]>
#   srcmgr update                               (git pull do $REPO)
#   srcmgr rebuild [--force]                    (recompila tudo em ordem)
#   srcmgr graph    <nome>                      (árvore de deps)
#   srcmgr prepare  <nome|arquivo.rc>           (fetch+extract+patch+deps)
#
# Variáveis globais (sobreponha via ambiente):
#   ROOT=/            destino final
#   REPO=$PWD         raiz do repositório de receitas (contém "repo/")
#   RECIPES_DIR=$REPO/repo
#   WORK=$PWD/work
#   DL=$PWD/distfiles
#   DESTDIR=$PWD/dest
#   PKGDIR=$PWD/packages
#   VARDB=/var/lib/srcmgr
#   LOGDIR=$PWD/logs
#   JOBS=$(getconf _NPROCESSORS_ONLN || echo 2)
#   PKGCOMP=gz|xz|zst (formato do pacote do DESTDIR)
#   USE_COLOR=1|0
#   USE_SPINNER=1|0
# ============================================================================

set -eu

###############################################################################
# Config padrão
: "${ROOT:=/}"
: "${REPO:=${PWD}}"
: "${RECIPES_DIR:=${REPO}/repo}"
: "${WORK:=${PWD}/work}"
: "${DL:=${PWD}/distfiles}"
: "${DESTDIR:=${PWD}/dest}"
: "${PKGDIR:=${PWD}/packages}"
: "${VARDB:=/var/lib/srcmgr}"
: "${LOGDIR:=${PWD}/logs}"
: "${JOBS:=$(getconf _NPROCESSORS_ONLN 2>/dev/null || echo 2)}"
: "${PKGCOMP:=gz}"

umask 022

###############################################################################
# Aparência (cores/spinner)
: "${USE_COLOR:=1}"
: "${USE_SPINNER:=1}"

if [ -t 2 ] && [ "$USE_COLOR" -eq 1 ]; then
  C_RESET="$(printf '\033[0m')"
  C_BOLD="$(printf '\033[1m')"
  C_DIM="$(printf '\033[2m')"
  C_RED="$(printf '\033[31m')"
  C_GRN="$(printf '\033[32m')"
  C_YEL="$(printf '\033[33m')"
  C_CYN="$(printf '\033[36m')"
else
  C_RESET=""; C_BOLD=""; C_DIM=""; C_RED=""; C_GRN=""; C_YEL=""; C_CYN="";
fi

ts(){ date -u +'%Y-%m-%dT%H:%M:%SZ'; }
log(){ printf '%s%s[*]%s %s\n' "$C_CYN" "$C_BOLD" "$C_RESET" "$*" >&2; }
ok(){  printf '%s%s[OK]%s %s\n' "$C_GRN" "$C_BOLD" "$C_RESET" "$*" >&2; }
warn(){printf '%s[!]%s %s\n' "$C_YEL" "$C_RESET" "$*" >&2; }
die(){ printf '%s%s[x]%s %s\n' "$C_RED" "$C_BOLD" "$C_RESET" "$*" >&2; exit 1; }

spinner() {
  # spinner "Mensagem" -- comando...
  if [ "$USE_SPINNER" -ne 1 ]; then shift; sh -c "$*"; return $?; fi
  msg=$1; shift
  printf '%s%s..%s ' "$C_DIM" "$msg" "$C_RESET" >&2
  (
    # roda comando numa subshell; saída vai p/ stdout/err normal
    sh -c "$*"
  ) &
  pid=$!
  i=0; chars='|/-\'
  while kill -0 "$pid" 2>/dev/null; do
    i=$(( (i+1) % 4 ))
    printf '\r%s%s %s%s' "$C_DIM" "$msg" "$(printf '%s' "$chars" | cut -c $((i+1)) )" "$C_RESET" >&2
    sleep 0.1
  done
  wait "$pid"; rc=$?
  printf '\r%*s\r' $(( ${#msg} + 4 )) '' >&2
  [ $rc -eq 0 ] && ok "$msg" || die "$msg falhou"
  return $rc
}

runlog(){
  # Executa com log (se LOGFILE definido), preservando RC
  if [ -n "${LOGFILE:-}" ]; then
    # shellcheck disable=SC2090
    ( sh -c "$*" ) 2>&1 | tee -a "$LOGFILE"
  else
    sh -c "$*"
  fi
}

need(){ command -v "$1" >/dev/null 2>&1 || die "comando requerido ausente: $1"; }
mkpaths(){ mkdir -p "$WORK" "$DL" "$DESTDIR" "$PKGDIR" "$VARDB/installed" "$LOGDIR" "$RECIPES_DIR"; }
sha256tool(){ command -v sha256sum >/dev/null 2>&1 && echo sha256sum || echo "shasum -a 256"; }
file_from_url(){ b=$(basename "$1"); printf '%s\n' "$b" | sed 's/[?].*$//'; }

###############################################################################
# Carregar receita
find_recipe(){
  name=$1
  case "$name" in
    *.rc) : ;;
    *) name="$name.rc" ;;
  esac

  # caminho direto?
  if [ -f "$name" ]; then echo "$name"; return 0; fi
  if [ -f "$RECIPES_DIR/$name" ]; then echo "$RECIPES_DIR/$name"; return 0; fi

  # busca em repo/*/
  f=$(find "$RECIPES_DIR" -maxdepth 3 -type f -name "$name" 2>/dev/null | head -n1 || true)
  [ -n "$f" ] || die "receita não encontrada: $1"
  echo "$f"
}

load_rc(){
  RCFILE=$(find_recipe "$1")
  RECDIR=$(CDPATH= cd -- "$(dirname -- "$RCFILE")" && pwd)

  # shellcheck disable=SC1090
  set -a; . "$RCFILE"; set +a

  # Normaliza nomes (aceita minúsculas herdadas)
  PKG="${PKG:-${pkgname:-}}"
  VER="${VER:-${pkgver:-}}"
  SRC="${SRC:-${url:-}}"
  SHA256="${SHA256:-${sha256:-}}"
  SHA256_FILES="${SHA256_FILES:-${sha256_files:-}}"
  PATCHES="${PATCHES:-${patches:-${PATCHES_LIST:-}}}"
  DEPS="${DEPS:-${deps:-}}"
  CONFIGURE="${CONFIGURE:-${configure:-}}"
  MAKE="${MAKE:-${make:-}}"
  MAKE_INSTALL="${MAKE_INSTALL:-${install:-}}"
  POST_INSTALL="${POST_INSTALL:-${post_install:-}}"
  REMOVE_CMDS="${REMOVE_CMDS:-${remove:-}}"
  BUILD_DIR="${BUILD_DIR:-${builddir:-${workdir:-}}}"

  : "${PKG:?defina PKG na receita}"
  : "${VER:?defina VER na receita}"
  : "${SRC:?defina SRC na receita}"

  PKGID="${PKG}-${VER}"
}

is_installed(){ [ -d "$VARDB/installed/$1" ]; }

###############################################################################
# FETCH / VERIFY / EXTRACT / PATCH
fetch_one(){
  u=$1
  case "$u" in
    git+http://*|git+https://*|git+ssh://*|*.git)
      need git
      url=$(printf '%s' "$u" | sed 's#^git\+##')
      name=$(basename "$url" .git)
      tgt="$WORK/${name}.git"
      if [ -d "$tgt" ]; then
        log "git fetch: $url"
        (cd "$tgt" && git fetch --all --tags --prune)
      else
        spinner "git clone --mirror $name" "git clone --mirror '$url' '$tgt'"
      fi
      ;;
    http://*|https://*|ftp://*)
      out="$DL/$(file_from_url "$u")"
      if [ -f "$out" ]; then
        ok "já baixado: $(basename "$out")"
      else
        if command -v curl >/dev/null 2>&1; then
          spinner "baixando $(basename "$out")" "curl -fL --retry 3 -o '$out' '$u'"
        else
          need wget
          spinner "baixando (wget) $(basename "$out")" "wget -O '$out' '$u'"
        fi
      fi
      ;;
    /*|./*|../*)
      cp -n "$u" "$DL/" 2>/dev/null || true
      ;;
    *)
      die "SRC desconhecido: $u"
      ;;
  esac
}

verify_sha(){
  s256=$(sha256tool)
  [ -z "${SHA256:-}${SHA256_FILES:-}" ] && { warn "sem SHA256 definido"; return 0; }

  # caso: único arquivo
  if [ -n "${SHA256:-}" ]; then
    first=$(printf '%s\n' $SRC | awk 'NF{print; exit}')
    f=$(file_from_url "$first")
    (cd "$DL" && echo "$SHA256  $f" | $s256 -c -) || die "SHA256 falhou: $f"
    ok "SHA256 OK: $f"
  fi

  # caso: múltiplos arquivos "arquivo=hash" (um por linha)
  if [ -n "${SHA256_FILES:-}" ]; then
    echo "$SHA256_FILES" | while IFS= read -r ln; do
      [ -z "$ln" ] && continue
      f=$(printf '%s' "$ln" | cut -d= -f1)
      h=$(printf '%s' "$ln" | cut -d= -f2-)
      (cd "$DL" && echo "$h  $f" | $s256 -c -) || die "SHA256 falhou: $f"
      ok "SHA256 OK: $f"
    done
  fi
}

extract_one(){
  s=$1
  case "$s" in
    *.git)
      need git
      name=$(basename "$s" .git)
      out="$WORK/src/$PKGID-$name"
      mkdir -p "$WORK/src"
      if [ -d "$out/.git" ]; then
        log "git update $name"
        (cd "$out" && git fetch && (git rev-parse --verify origin/HEAD >/dev/null 2>&1 && git reset --hard origin/HEAD) || true)
      else
        spinner "git clone $name" "git clone '$s' '$out'"
      fi
      ;;
    *.tar.gz|*.tgz)   mkdir -p "$WORK/src"; spinner "extraindo $(basename "$s")" "tar -xzf '$s' -C '$WORK/src'";;
    *.tar.bz2|*.tbz2) mkdir -p "$WORK/src"; spinner "extraindo $(basename "$s")" "tar -xjf '$s' -C '$WORK/src'";;
    *.tar.xz|*.txz)   mkdir -p "$WORK/src"; spinner "extraindo $(basename "$s")" "tar -xJf '$s' -C '$WORK/src'";;
    *.tar.zst|*.tzst) mkdir -p "$WORK/src"; spinner "extraindo $(basename "$s")" "tar --zstd -xpf '$s' -C '$WORK/src'";;
    *.zip)            mkdir -p "$WORK/src"; spinner "extraindo $(basename "$s")" "(cd '$WORK/src' && unzip -q '$s')";;
    *.gz)             mkdir -p "$WORK/src"; runlog "gunzip -c '$s' > '$WORK/src/$(basename "$s" .gz)'" ;;
    *.bz2)            mkdir -p "$WORK/src"; runlog "bunzip2 -c '$s' > '$WORK/src/$(basename "$s" .bz2)'" ;;
    *.xz)             mkdir -p "$WORK/src"; runlog "unxz -c '$s' > '$WORK/src/$(basename "$s" .xz)'" ;;
    *.zst)            mkdir -p "$WORK/src"; runlog "zstd -d -c '$s' > '$WORK/src/$(basename "$s" .zst)'" ;;
    *)
      warn "ignorado (formato?): $(basename "$s")"
      ;;
  esac
}

apply_patches(){
  [ -n "${PATCHES:-}" ] || { ok "sem patches"; return 0; }
  need patch
  for p in $PATCHES; do
    case "$p" in
      /*) patchfile="$p" ;;
      *)  patchfile="$RECDIR/$p" ;;
    esac
    [ -f "$patchfile" ] || die "patch não encontrado: $p"
    log "patch: $(basename "$patchfile")"
    (cd "$SRCDIR" && patch -p1 < "$patchfile")
  done
}

find_srcdir(){
  # ordem: BUILD_DIR, PKG-VER, primeiro diretório extraído
  if [ -n "${BUILD_DIR:-}" ] && [ -d "$BUILD_DIR" ]; then SRCDIR="$BUILD_DIR"; return; fi
  guess="$WORK/src/${PKG}-${VER}"
  if [ -d "$guess" ]; then SRCDIR="$guess"; return; fi
  d=$(find "$WORK/src" -mindepth 1 -maxdepth 1 -type d 2>/dev/null | head -n1 || true)
  [ -n "$d" ] || die "SRCDIR não encontrado (defina BUILD_DIR na receita)"
  SRCDIR="$d"
}

###############################################################################
# Etapas (fetch/extract/patch/build/install)
cmd_fetch(){
  mkpaths; load_rc "$1"
  LOGFILE="$LOGDIR/${PKGID}-fetch.log"
  for u in $SRC; do fetch_one "$u"; done
  verify_sha
}

cmd_extract(){
  cmd_fetch "$1"
  LOGFILE="$LOGDIR/${PKGID}-extract.log"
  for u in $SRC; do
    case "$u" in
      *.git|git+*) extract_one "$(printf '%s' "$u" | sed 's#^git\+##')" ;;
      http*|ftp*)  extract_one "$DL/$(file_from_url "$u")" ;;
      /*|./*|../*) extract_one "$DL/$(basename "$u")" ;;
    esac
  done
}

cmd_patch(){
  cmd_extract "$1"
  find_srcdir
  LOGFILE="$LOGDIR/${PKGID}-patch.log"
  apply_patches
}

# Dependências (instala recursivo quando houver receita)
install_deps(){
  for dep in ${DEPS:-}; do
    depfile=""
    depfile=$(find_recipe "$dep" 2>/dev/null || true) || true
    if [ -n "$depfile" ]; then
      # carregar para obter versão alvo
      set -a; . "$depfile"; set +a
      DPKG="${PKG:-${pkgname:-$dep}}"
      DVER="${VER:-${pkgver:-}}"
      DPKGID="$DPKG-${DVER:-0}"
      if is_installed "$DPKGID"; then
        ok "dep já instalada: $DPKGID"
      else
        log "instalando dependência: $dep"
        cmd_install "$dep"
      fi
    else
      warn "dep informativa (sem receita local): $dep"
    fi
  done
}

cmd_build(){
  mkpaths; load_rc "$1"
  LOGFILE="$LOGDIR/${PKGID}-build.log"

  # Preparação
  cmd_patch "$1" >/dev/null 2>&1 || true
  find_srcdir

  # Configure
  if [ -n "${CONFIGURE:-}" ]; then
    spinner "configure ($PKGID)" "(cd '$SRCDIR' && sh -c \"$CONFIGURE\")"
  fi

  # Build
  if [ -n "${MAKE:-}" ]; then
    spinner "make ($PKGID)" "(cd '$SRCDIR' && sh -c \"$MAKE\")"
  fi

  # DESTDIR clean
  rm -rf "$DESTDIR"; mkdir -p "$DESTDIR"

  # Install (fakeroot se disponível)
  if [ -n "${MAKE_INSTALL:-}" ]; then
    if command -v fakeroot >/dev/null 2>&1; then
      spinner "make install (fakeroot)" "(cd '$SRCDIR' && fakeroot sh -c \"$MAKE_INSTALL\")"
    else
      spinner "make install" "(cd '$SRCDIR' && sh -c \"$MAKE_INSTALL\")"
    fi
  fi

  # Empacotar conteúdo do DESTDIR
  mkdir -p "$PKGDIR"
  pkgfile="$PKGDIR/${PKG}-${VER}.tar.${PKGCOMP}"
  case "$PKGCOMP" in
    gz) (cd "$DESTDIR" && tar -czf "$pkgfile" .) ;;
    xz) (cd "$DESTDIR" && tar -cJf "$pkgfile" .) ;;
    zst) (cd "$DESTDIR" && tar --zstd -cpf "$pkgfile" .) ;;
    *) (cd "$DESTDIR" && tar -czf "$pkgfile" .) ;;
  esac
  ok "pacote gerado: $pkgfile"
}

install_to_root(){
  [ -d "$DESTDIR" ] || die "DESTDIR vazio (nada a instalar)"
  log "instalando em $ROOT"
  (cd "$DESTDIR" && tar -cpf - .) | (cd "$ROOT" && tar -xpf -)
}

write_manifest(){
  instdir="$VARDB/installed/${PKGID}"
  mkdir -p "$instdir"
  manifest="$instdir/manifest.txt"
  (cd "$DESTDIR" && find . -type f -o -type l -o -type d | sed 's#^\./##' | sort) > "$manifest"
  cp "$RCFILE" "$instdir/recipe.rc" 2>/dev/null || true
  {
    echo "PKG=$PKG"
    echo "VER=$VER"
    echo "TIME=$(ts)"
  } > "$instdir/meta"
}

post_install_root(){
  [ -z "${POST_INSTALL:-}" ] && return 0
  log "POST_INSTALL ($PKGID)"
  ( cd "$ROOT" && sh -c "$POST_INSTALL" ) || true
}

mark_installed(){
  instdir="$VARDB/installed/${PKGID}"
  mkdir -p "$instdir"
  : # meta/manifest já escritos
}

cmd_install(){
  FORCE=0
  # interpreta flag --force opcional
  case "${2:-}" in
    --force) FORCE=1 ;;
  esac

  mkpaths; load_rc "$1"
  LOGFILE="$LOGDIR/${PKGID}.log"

  if is_installed "$PKGID" && [ $FORCE -ne 1 ]; then
    ok "$PKGID já instalado"
    return 0
  fi

  install_deps
  cmd_build "$1"
  install_to_root
  post_install_root
  write_manifest
  mark_installed
  ok "instalado: $PKGID"
}

###############################################################################
# Remoção / Listagem / Info
cmd_remove(){
  name=$1
  case "$name" in
    *-*) pkgid="$name" ;;
    *)
      m=$(ls -1 "$VARDB/installed" 2>/dev/null | grep -E "^${name}-" || true)
      [ -n "$m" ] || die "não instalado: $name"
      cnt=$(printf '%s\n' "$m" | wc -l | tr -d ' ')
      [ "$cnt" -eq 1 ] || die "múltiplas versões para $name; use <nome>-<ver>"
      pkgid="$m"
      ;;
  esac

  instdir="$VARDB/installed/$pkgid"
  [ -d "$instdir" ] || die "não instalado: $pkgid"

  manifest="$instdir/manifest.txt"
  [ -f "$manifest" ] || die "manifesto ausente: $pkgid"

  log "removendo $pkgid"
  # remove caminhos em ordem do maior para o menor (dirs depois de arquivos)
  awk '{print length, $0}' "$manifest" | sort -rn | cut -d' ' -f2- |
  while IFS= read -r f; do
    [ -z "$f" ] && continue
    p="$ROOT/$f"
    if [ -L "$p" ] || [ -f "$p" ]; then
      rm -f "$p" 2>/dev/null || true
    elif [ -d "$p" ]; then
      rmdir "$p" 2>/dev/null || rm -rf "$p" 2>/dev/null || true
    fi
  done

  # comandos extras de remoção definidos na receita
  RCEX="$instdir/recipe.rc"
  if [ -f "$RCEX" ]; then
    set -a; . "$RCEX"; set +a
    if [ -n "${REMOVE_CMDS:-}" ]; then
      log "REMOVE_CMDS ($pkgid)"
      ( cd "$ROOT" && sh -c "$REMOVE_CMDS" ) || true
    fi
  fi

  rm -rf "$instdir"
  ok "removido: $pkgid"
}

cmd_list(){
  [ -d "$VARDB/installed" ] || { echo "(vazio)"; return 0; }
  ls -1 "$VARDB/installed" 2>/dev/null | sort
}

cmd_info(){
  name=$1
  dir="$VARDB/installed/$name"
  [ -d "$dir" ] || die "não instalado: $name"
  [ -f "$dir/meta" ] && cat "$dir/meta"
  echo "--- receita ---"
  sed -n '1,200p' "$dir/recipe.rc"
}

###############################################################################
# Update do repositório (git pull)
cmd_update(){
  [ -d "$REPO/.git" ] || die "REPO não é um repositório git: $REPO"
  (cd "$REPO" && git pull --ff-only)
  ok "repo atualizado"
}

###############################################################################
# prepare / graph / rebuild (ordenando por dependências)
cmd_prepare(){
  mkpaths; load_rc "$1"
  install_deps
  cmd_patch "$1"
  ok "prepare concluído: fontes baixadas, extraídas e patch aplicados"
}

cmd_graph(){
  load_rc "$1"
  echo "$PKG"
  _graph_visit "$PKG" "  "
}

_graph_visit(){
  pkg="$1"; indent="$2"
  rc=$(find_recipe "$pkg" 2>/dev/null || true) || true
  [ -n "$rc" ] || return 0
  set -a; . "$rc"; set +a
  deps_local="${DEPS:-${deps:-}}"
  for d in $deps_local; do
    printf '%s%s\n' "$indent" "$d"
    _graph_visit "$d" "  $indent"
  done
}

cmd_rebuild(){
  FORCE=0
  [ "${1:-}" = "--force" ] && FORCE=1

  # 1) listar todas as receitas
  pkgs=$(find "$RECIPES_DIR" -type f -name '*.rc' -printf '%f\n' 2>/dev/null | sed 's/\.rc$//' | sort)

  # 2) ordenação topológica por DFS (detecção de ciclos)
  order=""
  visited=""
  visiting=""

  topo_visit(){
    n="$1"
    case " $visited " in *" $n "*) return ;; esac
    case " $visiting " in *" $n "*) die "ciclo de dependências em $n" ;; esac
    visiting="$visiting $n"
    rc=$(find_recipe "$n" 2>/dev/null || true) || true
    if [ -n "$rc" ]; then
      set -a; . "$rc"; set +a
      deps_local="${DEPS:-${deps:-}}"
      for d in $deps_local; do topo_visit "$d"; done
    fi
    visiting=$(printf '%s' "$visiting" | sed "s/ $n//")
    visited="$visited $n"
    order="$order $n"
  }

  for p in $pkgs; do topo_visit "$p"; done

  # 3) executar na ordem
  for p in $order; do
    # se já instalado e não forçado, pula
    rc=$(find_recipe "$p" 2>/dev/null || true) || true
    [ -n "$rc" ] || { warn "sem receita: $p"; continue; }
    set -a; . "$rc"; set +a
    P="${PKG:-${pkgname:-$p}}"
    V="${VER:-${pkgver:-0}}"
    if [ $FORCE -eq 1 ]; then
      cmd_install "$p" --force
    else
      if is_installed "$P-$V"; then
        ok "skip $P-$V (instalado)"
      else
        cmd_install "$p"
      fi
    fi
  done
  ok "rebuild concluído"
}

###############################################################################
# Dispatcher
usage(){
  cat <<EOF
uso: $0 <comando> [args]

comandos:
  install  <nome|arquivo.rc> [--force]   compila+instala com registro/manifesto
  build    <nome|arquivo.rc>             compila e empacota (sem instalar)
  fetch    <nome|arquivo.rc>             baixa fontes
  extract  <nome|arquivo.rc>             baixa+extrai
  patch    <nome|arquivo.rc>             aplica patches
  deps     <nome|arquivo.rc>             instala dependências recursivamente
  remove   <nome[-ver]>                  remove pelo manifesto + REMOVE_CMDS
  list                                   lista pacotes instalados
  info     <nome[-ver]>                  metadados e receita salva
  update                                git pull do \$REPO
  rebuild  [--force]                     recompila tudo (ordem por deps)
  graph    <nome>                        imprime árvore de dependências
  prepare  <nome|arquivo.rc>             fetch+extract+patch+deps (sem build)

variáveis globais:
  ROOT REPO RECIPES_DIR WORK DL DESTDIR PKGDIR VARDB LOGDIR JOBS PKGCOMP
  USE_COLOR USE_SPINNER
EOF
}

[ $# -ge 1 ] || { usage; exit 1; }

case "$1" in
  install)  shift; [ $# -ge 1 ] || die "uso: install <nome|arquivo.rc> [--force]"; cmd_install "$@";;
  build)    shift; [ $# -ge 1 ] || die "uso: build <nome|arquivo.rc>"; cmd_build "$1";;
  fetch)    shift; [ $# -ge 1 ] || die "uso: fetch <nome|arquivo.rc>"; cmd_fetch "$1";;
  extract)  shift; [ $# -ge 1 ] || die "uso: extract <nome|arquivo.rc>"; cmd_extract "$1";;
  patch)    shift; [ $# -ge 1 ] || die "uso: patch <nome|arquivo.rc>"; cmd_patch "$1";;
  deps)     shift; [ $# -ge 1 ] || die "uso: deps <nome|arquivo.rc>"; load_rc "$1"; install_deps;;
  remove)   shift; [ $# -ge 1 ] || die "uso: remove <nome[-ver]>"; cmd_remove "$1";;
  list)     cmd_list;;
  info)     shift; [ $# -ge 1 ] || die "uso: info <nome[-ver]>"; cmd_info "$1";;
  update)   cmd_update;;
  rebuild)  shift; cmd_rebuild "${1:-}";;
  graph)    shift; [ $# -ge 1 ] || die "uso: graph <nome>"; cmd_graph "$1";;
  prepare)  shift; [ $# -ge 1 ] || die "uso: prepare <nome|arquivo.rc>"; cmd_prepare "$1";;
  help|-h|--help) usage;;
  *) die "comando desconhecido: $1";;
esac
